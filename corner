# -*- coding: cp949 -*-
# -*- coding: utf-8 -*-
import cv2 # opencv 사용
import numpy as np
import math
import matplotlib.patches as patches
import matplotlib.pyplot as plt

def grayscale(img): # 흑백이미지로 변환
    return cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

def canny(img, low_threshold, high_threshold): # Canny 알고리즘
    return cv2.Canny(img, low_threshold, high_threshold, apertureSize = 5, L2gradient = True)

def gaussian_blur(img, kernel_size): # 가우시안 필터
    return cv2.GaussianBlur(img, (kernel_size, kernel_size), 0)

def region_of_interest(img, vertices, color3=(255,255,255), color1=255): # ROI 셋팅

    mask = np.zeros_like(img) # mask = img와 같은 크기의 빈 이미지
    
    if len(img.shape) > 2: # Color 이미지(3채널)라면 :
        color = color3
    else: # 흑백 이미지(1채널)라면 :
        color = color1
        
    # vertices에 정한 점들로 이뤄진 다각형부분(ROI 설정부분)을 color로 채움 
    cv2.fillPoly(mask, vertices, color)
    
    # 이미지와 color로 채워진 ROI를 합침
    ROI_image = cv2.bitwise_and(img, mask)
    return ROI_image

def cross_point(img, x11,y11, x12,y12, x21,y21, x22,y22):
    pt=[x11,y11, x12,y12, x21,y21, x22,y22]
    if x11 == x12 or x21 == x22:
        if x11 == x12 and x21 != x22:
            cx = x12
            m2 = (y22 - y21) / (x22 - x21)
            cy = int(m2 * (cx - x21) + y21)
            draw_cpLine(img,cx,cy,pt)
            
        elif x21 == x22 and x11 != x12:
            cx = x22
            m1 = (y12 - y11) / (x12 - x11)
            cy = int(m1 * (cx - x11) + y11)
            draw_cpLine(img,cx,cy,pt)
    
    elif x11 != x12 and x21 != x22:
        m1 = (y12 - y11) / (x12 - x11)
        m2 = (y22 - y21) / (x22 - x21)
        if m1 == m2:
            if x12 == x21:
                m = (y22 - y12) / (x22 - x12)
                if m == m1:
                    cx,cy = x12,y12
                    draw_cpLine(img,cx,cy,pt)
            else:
                m = (y21 - y12) / (x21 - x12)
                if m == m1:
                    cx,cy = x12,y12
                    draw_cpLine(img,cx,cy,pt)
        else:
            cx = int((x11 * m1 - y11 - x21 * m2 + y21) / (m1 - m2))
            cy = int(m1 * (cx - x11) + y11)
            draw_cpLine(img,cx,cy,pt)
            
            theta = abs(math.atan(m1) - math.atan(m2))
            theta = theta * 180 / np.pi
            
def distance(x0,y0,x1,y1):
    dx = x0 - x1
    dy = y0 - y1
    dist = math.sqrt((dx*dx)+(dy*dy))
    return dist
            
def draw_cpLine(img,cx,cy,pt):
    for i in range(4):
        dist = distance(cx, cy, pt[2*i], pt[2*i+1])
        if dist < 20:
            cv2.line(img,(cx,cy),(pt[2*i],pt[2*i+1]),(255,0,0),2)
            
def find_area(x0,y0,x1,y1,h0,w0,h1,h2,w1,w2):
    if (x0 in range(w1,w2)) and (y0 in range(0,h1)):
        area0=1
    elif (x0 in range(0,w1)) and (y0 in range(h1,h2)):
        area0=2
    elif (x0 in range(w1,w2)) and (y0 in range(h2,h0)):
        area0=3
    elif (x0 in range(w2,w0)) and (y0 in range(h1,h2)):
        area0=4
    else:
        area0=0
        
    if (x1 in range(w1,w2)) and (y1 in range(0,h1)):
        area1=1
    elif (x1 in range(0,w1)) and (y1 in range(h1,h2)):
        area1=2
    elif (x1 in range(w1,w2)) and (y1 in range(h2,h0)):
        area1=3
    elif (x1 in range(w2,w0)) and (y1 in range(h1,h2)):
        area1=4
    else:
        area1=0
        
    return area0,area1

def identify(a0,a1):
    if a0 != a1:
        if a0 * a1 == 0:
            sign0 = {1:1, 2:3, 3:2, 4:4}.get(a0 + a1, None)
            # 1:up, 2:down, 3:left, 4:right
            return [0,sign0]
        else:
            if (a0 + a1) % 2 == 0:
                if (a0 * a1) % 2 == 0:
                    sign1 = [3,4]
                else:
                    sign1 = [1,2]
                return [1,sign1]
            
def Write_shape(img,ID):
    num = len(ID)
    font = cv2.FONT_HERSHEY_COMPLEX
    text = ""
    for i in range(num):
        sign = {1:"up", 2:"down", 3:"left", 4:"right"}.get(ID[i], None)
        text = text + " " + sign
    img = cv2.putText(img, text, (50, 50), font, 1, (0,255,255), 2, cv2.LINE_AA)
    return img


cap = cv2.VideoCapture(0)
contours=[]

while(cap.isOpened()):
    ret, image = cap.read()
    
    hsv_img = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)
    #색상영역 지정
    yellow1 = np.array([20,50,50])
    yellow2 = np.array([35,255,255])
    #마스크 생성
    mask_yellow = cv2.inRange(hsv_img,yellow1,yellow2)
    #색상별 마스크로 색상 추출
    res_yellow = cv2.bitwise_and(image,image,mask=mask_yellow)
    
    bgr_img = cv2.cvtColor(res_yellow,cv2.COLOR_HSV2BGR)

    height, width = bgr_img.shape[:2] # 이미지 높이, 너비

    gray_img = grayscale(bgr_img) # 흑백이미지로 변환
    
    blur_img = gaussian_blur(gray_img, 3) # Blur 효과
        
    canny_img = canny(blur_img, 5000, 1500) # Canny edge 알고리즘
    
    contours0 = cv2.findContours(canny_img,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)[0]
    contour_img = cv2.drawContours(canny_img,contours0,-1,(255,0,0),2)
    
    lines = cv2.HoughLinesP(contour_img, 1, 1 * np.pi / 180, 60, np.array([]), minLineLength = 10, maxLineGap = 100)
    hough_img = np.zeros((image.shape[0], image.shape[1], 3), dtype=np.uint8)
    
    
    get_sign=[]
    sign=[]
    #검출 라인 분석
    if lines is not None:
        point=[]
        h1,h2,w1,w2 = int(height/2 - 100), int(height/2 + 100), int(width/2 - 100), int(width/2 + 100)
        for line in lines:
            x0,y0,x1,y1 = int(line[0][0]), int(line[0][1]), int(line[0][2]), int(line[0][3])
            if distance(x0,y0,x1,y1) >= 100:
                point.append(x0)
                point.append(y0)
                point.append(x1)
                point.append(y1)
                cv2.line(hough_img, (x0, y0), (x1, y1), (0, 0, 255), 2)
                if (x0 > w1 and x0 < w2) or (y0 > h1 and y0 < h2):
                    if (x1 > w1 and x1 < w2) or (y1 > h1 and y1 < h2):
                        area0,area1 = find_area(x0,y0,x1,y1,height,width,h1,h2,w1,w2)
                        try:
                            ID = identify(area0,area1)
                            if ID[0] == 0:
                                get_sign.append(ID[1])
                            elif ID[0] == 1:
                                get_sign.extend(ID[1])
                        except:
                            pass
                            
        sign = list(set(get_sign))
        
        num=int(len(point) / 4)
        if num >= 4:
            for i in range(num-1):
                for j in range(i+1,num):
                    cross_point(hough_img,point[4*i],point[4*i+1],point[4*i+2],point[4*i+3],point[4*j],point[4*j+1],point[4*j+2],point[4*j+3])
            
    hough_img = cv2.cvtColor(hough_img,cv2.COLOR_BGR2GRAY)
    result_img = np.zeros((image.shape[0], image.shape[1], 3), dtype=np.uint8)
    contours.append(cv2.findContours(hough_img,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)[0])
    num_cont = len(contours)
    for i in range(num_cont-3,num_cont):
        if i < 0:
            i=0
        result_img = cv2.drawContours(result_img,contours[i],-1,(255,255,255),10)
    
    result_img = cv2.cvtColor(result_img,cv2.COLOR_BGR2GRAY)
    vertices = np.array([[(width/2-100,height/2+100), (width/2+100,height/2+100), (width/2+150,height/2-100), (width/2-100,height/2-100)]], dtype=np.int32)
    ROI_img = region_of_interest(result_img, vertices) # ROI 설정
    
    #시-토마스의 코너 검출 메서드
    corners=cv2.goodFeaturesToTrack(ROI_img,2,0.01,10)
    if corners is not None:
        #실수좌표를 정수좌표로 변환
        corners=np.int32(corners)
    
        #좌표 표시
        for corner in corners:
            x,y=corner[0]
            cv2.circle(image,(x,y),10,(255,0,0),1,cv2.LINE_AA)
    
    result_img = cv2.cvtColor(result_img,cv2.COLOR_GRAY2BGR)
    if len(sign) != 0:
        result_img = Write_shape(result_img,sign)
    cv2.imshow('origin',image)
    cv2.imshow('corner',result_img)
    
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break
# Release
cap.release()
cv2.destroyAllWindows()
